
#!/usr/bin/env python3
import rospy
import math
from nav_msgs.msg import Odometry, Path
from geometry_msgs.msg import Twist

def yaw_from_quat(q):
    siny_cosp = 2.0 * (q.w*q.z + q.x*q.y)
    cosy_cosp = 1.0 - 2.0 * (q.y*q.y + q.z*q.z)
    return math.atan2(siny_cosp, cosy_cosp)

def wrap(a):
    while a > math.pi:
        a -= 2.0*math.pi
    while a < -math.pi:
        a += 2.0*math.pi
    return a

def clamp(v, lo, hi):
    return max(lo, min(hi, v))

class FollowerTrailFollow:
    def __init__(self):
        self.follower_odom = rospy.get_param("~follower_odom", "/follower/odom")
        self.path_topic    = rospy.get_param("~path_topic", "/leader/trail_path")
        self.cmd_out       = rospy.get_param("~cmd_out", "/follower/cmd_vel_raw")

        # how far behind (in recorded poses)
        self.delay_poses = int(rospy.get_param("~delay_poses", 25))

        # controller tuning
        self.k_lin   = float(rospy.get_param("~k_lin", 1.2))
        self.k_ang   = float(rospy.get_param("~k_ang", 2.5))
        self.max_lin = float(rospy.get_param("~max_lin", 0.35))
        self.max_ang = float(rospy.get_param("~max_ang", 1.2))
        self.arrive_dist = float(rospy.get_param("~arrive_dist", 0.25))

        self.path = None
        self.pose = None

        rospy.Subscriber(self.path_topic, Path, self.path_cb, queue_size=10)
        rospy.Subscriber(self.follower_odom, Odometry, self.odom_cb, queue_size=20)
        self.pub = rospy.Publisher(self.cmd_out, Twist, queue_size=10)

        self.timer = rospy.Timer(rospy.Duration(0.1), self.step)  # 10 Hz
        rospy.loginfo("FollowerTrailFollow ON. follower_odom=%s path=%s cmd_out=%s delay_poses=%d",
                      self.follower_odom, self.path_topic, self.cmd_out, self.delay_poses)

    def path_cb(self, msg):
        self.path = msg

    def odom_cb(self, msg):
        self.pose = msg.pose.pose

    def step(self, _evt):
        if self.path is None or self.pose is None:
            return
        if len(self.path.poses) < self.delay_poses + 1:
            # not enough trail yet
            self.pub.publish(Twist())
            return

        # target point on trail (delayed)
        target = self.path.poses[-self.delay_poses].pose.position
        tx, ty = target.x, target.y

        fx, fy = self.pose.position.x, self.pose.position.y
        fyaw = yaw_from_quat(self.pose.orientation)

        dx, dy = tx - fx, ty - fy
        dist = math.hypot(dx, dy)

        cmd = Twist()
        if dist < self.arrive_dist:
            self.pub.publish(cmd)
            return

        target_yaw = math.atan2(dy, dx)
        yaw_err = wrap(target_yaw - fyaw)

        # slow down if turning hard (car-like smoother)
        turn_penalty = max(0.15, 1.0 - min(abs(yaw_err), math.pi)/math.pi)

        v = self.k_lin * dist * turn_penalty
        w = self.k_ang * yaw_err

        cmd.linear.x  = clamp(v, 0.0, self.max_lin)
        cmd.angular.z = clamp(w, -self.max_ang, self.max_ang)
        self.pub.publish(cmd)

if __name__ == "__main__":
    rospy.init_node("follower_trail_follow")
    FollowerTrailFollow()
    rospy.spin()
